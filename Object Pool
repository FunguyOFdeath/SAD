#include <iostream> // Подключение заголовочного файла для ввода и вывода.
#include <vector> // Подключение заголовочного файла для использования контейнера вектор.
using namespace std; // Использование пространства имен std для упрощения кода.

class Object // Объявление класса Object.
{
private:
    int apples; // Приватная переменная для хранения количества яблок.
    int bananas; // Приватная переменная для хранения количества бананов.
    int oranges; // Приватная переменная для хранения количества апельсинов.
public:
    Object() // Конструктор по умолчанию.
    {
       apples = 10; // Инициализация переменной apples значением 10.
       bananas = 20; // Инициализация переменной bananas значением 20.
       oranges = 30; // Инициализация переменной oranges значением 30.
    }

    void print() // Метод для вывода количества фруктов.
    {
        cout << apples << " " << bananas << " " << oranges << endl; // Вывод количества фруктов на экран.
    }
};


class ObjectPool // Объявление класса ObjectPool.
{
private:
    struct PoolRecord // Структура для хранения записей пула.
    {
        Object* instance; // Указатель на экземпляр объекта.
        bool in_use; // Флаг, указывающий на использование объекта.
    };
    vector<PoolRecord> m_pool; // Вектор для хранения записей пула.

public:
    Object* createNewObject() // Метод для создания нового объекта или получения существующего.
    {
        for (size_t i = 0; i < m_pool.size(); ++i) // Цикл по всем записям пула.
        {
            if (!m_pool[i].in_use) // Если объект не используется.
            {
                m_pool[i].in_use = true; // Помечаем объект как используемый.
                return m_pool[i].instance; // Возвращаем указатель на объект.
            }
        }
        // Если не нашли свободный объект, то расширяем пул.
        PoolRecord record; // Создание новой записи пула.
        record.instance = new Object(); // Создание нового объекта.
        record.in_use = true; // Помечаем объект как используемый.

        m_pool.push_back(record); // Добавляем запись в пул.

        return record.instance; // Возвращаем указатель на новый объект.
    }

    void deleteObject(Object* object) // Метод для "удаления" объекта (помечаем его как неиспользуемый).
    {
        // В реальности не удаляем, а лишь помечаем, что объект свободен.
        for (size_t i = 0; i < m_pool.size(); ++i) // Цикл по всем записям пула.
        {
            if (m_pool[i].instance == object) // Если нашли указанный объект.
            {
                m_pool[i].in_use = false; // Помечаем объект как неиспользуемый.
                break; // Прерываем цикл.
            }
        }
    }

    virtual ~ObjectPool() // Деструктор.
    {
        // Теперь уже "по-настоящему" удаляем объекты.
        for (size_t i = 0; i < m_pool.size(); ++i) // Цикл по всем записям пула.
            delete m_pool[i].instance; // Удаление объекта.
    }
};


int main() // Главная функция программы.
{
    ObjectPool pool; // Создание экземпляра объектного пула.
    for (size_t i = 0; i < 100; ++i) // Цикл для создания и использования 100 объектов

.
    {
        Object* object = pool.createNewObject(); // Создание или получение объекта из пула.
        object->print(); // Вывод информации об объекте.
    }
    return 0; // Завершение программы с кодом 0.
}
